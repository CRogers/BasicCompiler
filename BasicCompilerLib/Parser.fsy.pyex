%{

open Tree

let sp (itemA:Annot) = itemA.Pos.StartPos
let ep (itemA:Annot) = itemA.Pos.EndPos

let v = snd<Pos,_>
let p = fst<Pos,_>
let markers (lpos:Pos) (rpos:Pos) = Pos(lpos.StartPos, rpos.EndPos)

(*annotate using markers*)
let tbb item lpos rpos = TopDeclA(item, markers lpos rpos)
let tba item lpos (rightA:Annot)          = tbb item lpos rightA.Pos
let tab item (leftA:Annot) rpos           = tbb item leftA.Pos rpos
let taa item (leftA:Annot) (rightA:Annot) = tbb item leftA.Pos rightA.Pos

let nbb item lpos rpos = NamespaceDeclA(item, markers lpos rpos)
let nba item lpos (rightA:Annot)          = nbb item lpos rightA.Pos
let nab item (leftA:Annot) rpos           = nbb item leftA.Pos rpos
let naa item (leftA:Annot) (rightA:Annot) = nbb item leftA.Pos rightA.Pos

let cbb item lpos rpos = ClassDeclA(item, markers lpos rpos)
let cba item lpos (rightA:Annot)          = cbb item lpos rightA.Pos
let cab item (leftA:Annot) rpos           = cbb item leftA.Pos rpos
let caa item (leftA:Annot) (rightA:Annot) = cbb item leftA.Pos rightA.Pos

let ibb item lpos rpos = InterfaceDeclA(item, markers lpos rpos)
let iba item lpos (rightA:Annot)          = ibb item lpos rightA.Pos
let iab item (leftA:Annot) rpos           = ibb item leftA.Pos rpos
let iaa item (leftA:Annot) (rightA:Annot) = ibb item leftA.Pos rightA.Pos

let ebb item lpos rpos = ExprA(item, markers lpos rpos)
let eba item lpos (rightA:Annot)          = ebb item lpos rightA.Pos
let eab item (leftA:Annot) rpos           = ebb item leftA.Pos rpos
let eaa item (leftA:Annot) (rightA:Annot) = ebb item leftA.Pos rightA.Pos

let ea item pos = ExprA(item, pos)

%}

$py(binops=['Add','Sub','Div','Mul','BoolAnd','BoolOr','Not','Lt','Gt','LtEq','GtEq','Eq'])

%token<(Pos * int64)>  INT8 INT16 INT32 INT64 
%token<(Pos * string)> IDENT
%token<Pos>            TRUE FALSE
%token<Pos>            $for(binop in binops)$(binop.upper()) $endfor
%token<Pos>            LPAR RPAR EOF PRINT COMMA COLON
%token<Pos>            RETURN LCURLY RCURLY SEMI START PROC EQUALS LET
%token<Pos>            IF THEN ELSE WHILE DO VAR
%token<Pos>            NAMESPACE CLASS STRUCT INTERFACE
%token<Pos>            PRIVATE PUBLIC
%token<Pos>            STATIC CONSTRUCTOR
%token<Pos>            ARROW USING DOT SRO

%type<CompilationUnit> program
%start program

%left SEMI
%left BOOLOR
%left BOOLAND
%left NOT
%left LT GT LTEQ GTEQ EQ
%left ADD SUB
%left DIV
%left MUL

%right ARROW

%%

program: topLevelDecls EOF
    { \$1 }

topLevelDecls:
    | /* empty */
        { [] }
    | USING scopeResolvedName SEMI topLevelDecls
        { tbb (Using \$2) \$1 \$3 :: \$4 }
    | NAMESPACE scopeResolvedName LCURLY namespaceDecls RCURLY topLevelDecls
        { tbb (Namespace (\$2, \$4)) \$1 \$3 :: \$6 }

scopeResolvedName:
    | IDENT
        { v \$1 }
    | IDENT SRO scopeResolvedName
        { v \$1 + "::" + \$3 }

visibility:
    | /* empty */
        { Private }
    | PRIVATE
        { Private }
    | PUBLIC
        { Public }

static_:
    | /* empty */
        { NotStatic }
    | STATIC
        { Static }

visibilityStatic:
    | /* empty */
        { (Private, NotStatic) }

classOrStruct:
    | STRUCT
        { Struct }
    | CLASS
        { NotStruct }

namespaceDecls:
    | /* empty */
        { [] }
    | visibility classOrStruct IDENT LCURLY classDecls RCURLY namespaceDecls
        { nbb (Class (v \$3, \$1, \$2, \$5)) (p \$3) \$4 :: \$7 }
    | visibility INTERFACE IDENT LCURLY interfaceDecls RCURLY namespaceDecls
        { nbb (Interface (v \$3, \$1, \$5)) \$2 \$4 :: \$7 }

interfaceDecls:
    | /* empty */
        { [] }
    | IDENT LPAR params RPAR possibleReturnType SEMI interfaceDecls
        { ibb (InterfaceProc (v \$1, \$3, ref \$5)) (p \$1) \$6 :: \$7 }

classDecls:
    | /* empty */
        { [] }
    | visibility static_ VAR IDENT COLON possibleType EQUALS expr3 SEMI classDecls
        { cbb (ClassVar (v \$4, \$1, \$2, ref \$6, \$8)) \$3 \$9 :: \$10 }
    | visibility static_ IDENT LPAR params RPAR possibleReturnType LCURLY expr0 RCURLY classDecls
        { cba (ClassProc (v \$3, \$1, \$2, ref \$5, ref \$7, \$9)) (p \$3) \$9 :: \$11 }

possibleType:
    | /* empty */
        { Undef }
    | ptype
        { \$1 }

ptype:
    | scopeResolvedName
        { UserType \$1 }
    | LPAR ptypeList RPAR ARROW ptype
        { PFunc (\$2, \$5) }

ptypeList:
    | /* empty */
        { [] }
    | ptype COMMA ptypeList
        { \$1 :: \$3 }

possibleReturnType:
    | /* empty */
        { commonPtype Unit }
    | COLON ptype
        { \$2 }

params:
    | /* empty */
        { [] }
    | IDENT COLON ptype
        { [Param(v \$1, \$3)] }
    | IDENT COLON ptype COMMA params
        { Param(v \$1, \$3) :: \$5 }

expr0:
    | expr1
        { \$1 }
    | expr1 expr0
        { eaa (Seq (\$1, \$2)) \$1 \$2 }

expr1:
    | expr4 EQUALS expr3 SEMI
        { eaa (Assign (\$1, \$3)) \$1 \$3 }
    | PRINT expr3 SEMI
        { eba (Print \$2) \$1 \$2 }
    | VAR IDENT EQUALS expr3 SEMI
        {   let var = ea (Var (v \$2)) (p \$2)
            let assign = eba (Assign (var, \$4)) (p \$2) \$4
            eba (DeclVar (v \$2, assign)) \$1 \$4 }
    | RETURN expr3 SEMI
        { eba (Return \$2) \$1 \$2 }
    | RETURN SEMI
        { ea ReturnVoid \$1  }
    | IF LPAR expr3 RPAR expr2 ELSE expr2
        { eba (If (\$3, \$5, \$7)) \$1 \$5 }
    | WHILE LPAR expr3 RPAR expr2
        { ebb (While (\$3, \$5)) \$1 \$4 }
    | expr2 
        { \$1 }

expr2:
    | expr3 SEMI
        { \$1 }
    | LCURLY expr0 RCURLY
        { \$2 }

expr3:  
$for(binop in binops)\
    | expr3 $(binop.upper()) expr3
        { eaa (Binop ($(binop), \$1, \$3)) \$1 \$3 }
$endfor\
    | expr4 LPAR argList RPAR  
        { eab (Call (\$1, \$3)) \$1 \$4 }
    | expr4
        { \$1 }

expr4:
    | LPAR RPAR
        { ebb ConstUnit \$1 \$2 }
    | IDENT
        { ea (Var (v \$1)) (p \$1) }
    | TRUE
        { ea (ConstBool true) \$1 }
    | FALSE
        { ea (ConstBool false) \$1 }
$for(x in [8,16,32,64])\
    | INT$(x)
        { ea (ConstInt ($(x), v \$1)) (p \$1) }
$endfor\
    | expr5
        { \$1 }

expr5:
    | expr4 DOT IDENT
        { eab (Dot (\$1, v \$3)) \$1 (p \$3) }
    | LPAR expr3 RPAR
        { \$2 }

argList:
    | /* empty */
        { [] }
    | expr3
        { [\$1] }
    | expr3 COMMA argList
        { \$1 :: \$3 }