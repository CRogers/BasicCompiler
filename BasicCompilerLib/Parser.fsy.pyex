%{

open Tree

let sp (itemA:Annot<_>) = itemA.Pos.StartPos
let ep (itemA:Annot<_>) = itemA.Pos.EndPos

let v = snd<Pos,_>
let p = fst<Pos,_>
let markers (lpos:Pos) (rpos:Pos) = Pos(lpos.StartPos, rpos.EndPos)

(*annotate*)
let a item pos = Annot(item, pos)
(*annotate using markers*)
let ambb item lpos rpos = Annot(item, markers lpos rpos)
let amba item lpos (rightA:Annot<_>) = ambb item lpos rightA.Pos
let amab item (leftA:Annot<_>) rpos = ambb item leftA.Pos rpos
(*annotate using markers that are annotated*)
let amaa item (leftA:Annot<_>) (rightA:Annot<_>) = ambb item leftA.Pos rightA.Pos

%}

$py(binops=['Add','Sub','Div','Mul','BoolAnd','BoolOr','Not','Lt','Gt','LtEq','GtEq','Eq'])

%token<(Pos * int)>    CONSTINT
%token<(Pos * string)> IDENT
%token<Pos>            TRUE FALSE
%token<Pos>            $for(binop in binops)$(binop.upper()) $endfor
%token<Pos>            LPAR RPAR EOF PRINT COMMA COLON
%token<Pos>            RETURN LCURLY RCURLY SEMI START PROC EQUALS LET
%token<Pos>            IF ELSE

%type<Program> program
%start program

%left BOOLOR
%left BOOLAND
%left NOT
%left LT GT LTEQ GTEQ EQ
%left ADD SUB
%left DIV
%left MUL

%%

program: decls EOF                  { \$1 }

decls:
    | procDecls START block         { ambb (Proc ("main", [], Int, v \$3)) \$2 (p \$3) :: \$1 }


procDecls:
    | /* empty */                   { [] }
    | PROC IDENT LPAR paramList RPAR returnType block procDecls
        { ambb (Proc (v \$2, \$4, \$6, v \$7)) \$1 (p \$7) :: \$8 }

returnType:
    | /* empty */                   { Unit }
    | COLON IDENT                   { parsePType <| v \$2 }

paramList:
    | /* empty */                   { [] }
    | param                         { [\$1] }
    | param COMMA paramList         { \$1 :: \$3 }

param:
    | IDENT COLON IDENT             { Param (v \$1, parsePType <| v \$3) }

block:
    | LCURLY stmts RCURLY           { (Pos(\$1.StartPos, \$3.EndPos), \$2) }

stmts:
    | /* empty */                   { [] }
    | stmt SEMI stmts               { \$1 :: \$3 }

stmt:
    | PRINT expr                    { amba (Print \$2) \$1 \$2 }
    | IDENT EQUALS expr             { amba (Assign (v \$1, \$3)) (p \$1) \$3 }
    | RETURN expr                   { amba (Return \$2) \$1 \$2 }
    | IF expr LCURLY stmts RCURLY possibleElse
        { ambb (If (\$2, \$4, \$6)) \$1 \$5 }

possibleElse:
    | /* empty */                   { [] }
    | ELSE LCURLY stmts RCURLY      { \$3 }

expr:
    | CONSTINT
        { a (ConstInt (v \$1)) (p \$1) }
    | TRUE
        { a (ConstBool true) \$1 }
    | FALSE
        { a (ConstBool false) \$1 }
$for(binop in binops)\
    | expr $(binop.upper()) expr
        { amaa (Binop ($(binop), \$1, \$3)) \$1 \$3 }
$endfor\
    | IDENT LPAR argList RPAR       
        { ambb (Call (v \$1, \$3)) (p \$1) \$4 }
	| IDENT
        { a (Var (v \$1)) (p \$1) }
    | LPAR expr RPAR
        { \$2 }

argList:
    | /* empty */                   { [] }
    | expr                          { [\$1] }
    | expr COMMA argList            { \$1 :: \$3 }