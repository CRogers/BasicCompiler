%{

open Tree

let sp (itemA:Annot) = itemA.Pos.StartPos
let ep (itemA:Annot) = itemA.Pos.EndPos

let v = snd<Pos,_>
let p = fst<Pos,_>
let markers (lpos:Pos) (rpos:Pos) = Pos(lpos.StartPos, rpos.EndPos)

(*annotate using markers*)
let tbb item lpos rpos = TopDeclA(item, markers lpos rpos)
let tba item lpos (rightA:Annot)          = tbb item lpos rightA.Pos
let tab item (leftA:Annot) rpos           = tbb item leftA.Pos rpos
let taa item (leftA:Annot) (rightA:Annot) = tbb item leftA.Pos rightA.Pos

let nbb item lpos rpos = NamespaceDeclA(item, markers lpos rpos)
let nba item lpos (rightA:Annot)          = nbb item lpos rightA.Pos
let nab item (leftA:Annot) rpos           = nbb item leftA.Pos rpos
let naa item (leftA:Annot) (rightA:Annot) = nbb item leftA.Pos rightA.Pos

let cbb item lpos rpos = ClassDeclA(item, markers lpos rpos)
let cba item lpos (rightA:Annot)          = cbb item lpos rightA.Pos
let cab item (leftA:Annot) rpos           = cbb item leftA.Pos rpos
let caa item (leftA:Annot) (rightA:Annot) = cbb item leftA.Pos rightA.Pos

let ibb item lpos rpos = InterfaceDeclA(item, markers lpos rpos)
let iba item lpos (rightA:Annot)          = ibb item lpos rightA.Pos
let iab item (leftA:Annot) rpos           = ibb item leftA.Pos rpos
let iaa item (leftA:Annot) (rightA:Annot) = ibb item leftA.Pos rightA.Pos

let ebb item lpos rpos = ExprA(item, markers lpos rpos)
let eba item lpos (rightA:Annot)          = ebb item lpos rightA.Pos
let eab item (leftA:Annot) rpos           = ebb item leftA.Pos rpos
let eaa item (leftA:Annot) (rightA:Annot) = ebb item leftA.Pos rightA.Pos

let ea item pos = ExprA(item, pos)


let nop = ea Nop Pos.NilPos

let applyTypeParamsConstraints<'a when 'a :> ITemplate> tps tcs (item:ITemplate) list_ =
    if List.length tps > 0 then
        item.TypeParams <- tps
    if List.length tcs > 0 then
        item.TypeConstraints <- tcs
    let casted = item :?> 'a
    casted :: list_

%}

$py(binops=['BINOP' + str(x) for x in range(0,7)])

%token<(Pos * int64)>  INT8 INT16 INT32 INT64 
%token<(Pos * string)> IDENT TYPENAME$for(binop in binops) $(binop)$endfor
%token<Pos>            TRUE FALSE
%token<Pos>            LPAR RPAR EOF PRINT COMMA COLON
%token<Pos>            RETURN LCURLY RCURLY LSQUARE RSQUARE SEMI START PROC EQUALS LET
%token<Pos>            IF THEN ELSE WHILE DO VAR
%token<Pos>            NAMESPACE CLASS STRUCT INTERFACE
%token<Pos>            PRIVATE PUBLIC
%token<Pos>            STATIC CONSTRUCTOR
%token<Pos>            ARROW USING DOT SRO GENSPACEOP WHERE

%type<CompilationUnit> program
%start program

%left SEMI
$for(binop in binops)\
%left $(binop)
$endfor\
%right ARROW

%%

program: topLevelDecls EOF
    { \$1 }


visibility:
    | /* empty */
        { Private }
    | PRIVATE
        { Private }
    | PUBLIC
        { Public }

static_:
    | /* empty */
        { NotStatic }
    | STATIC
        { Static }

classOrStruct:
    | STRUCT
        { Struct }
    | CLASS
        { NotStruct }

typeName:
    | TYPENAME
        { \$1 }
    | TYPENAME SRO typeName
        { (markers (p \$1) (p \$3), v \$1 + "::" + v \$3) }

typeNameList:
    | typeName
        { [v \$1] }
    | typeName COMMA typeNameList
        { v \$1 :: \$3 }

ptype:
    | typeName
        { InitialType (v \$1) }
    | typeName GENSPACEOP LSQUARE ptypeList RSQUARE
        { ParamedType (InitialType <| v \$1, \$4)  }

ptypeList:
    | ptype
        { [\$1] }
    | ptype COMMA ptypeList
        { \$1 :: \$3 }

ifaceImplements:
    | /* empty */
        { [] }
    | COLON ptypeList
        { \$2 }

identOrBinop:
    | IDENT
        { (\$1, false) }
$for(binop in binops)\
    | $(binop)
        { (\$1, true) }
$endfor\

possType:
    | /* empty */
        { Undef }
    | ptype
        { \$1 }

possReturnType:
    | /* empty */
        { InitialType "System::Unit" }
    | COLON ptype
        { \$2 }

possTypeParams:
    | /* empty */
        { [] }
    | GENSPACEOP LSQUARE typeNameList RSQUARE
        { \$3 }

possConstraints:
    | /* empty */
        { [] }
    | WHERE params
        { \$2 }


params:
    | /* empty */
        { [] }
    | IDENT COLON ptype
        { [Param(v \$1, \$3)] }
    | IDENT COLON ptype COMMA params
        { Param(v \$1, \$3) :: \$5 }

argList:
    | /* empty */
        { [] }
    | expr3
        { [\$1] }
    | expr3 COMMA argList
        { \$1 :: \$3 }


topLevelDecls:
    | /* empty */
        { [] }
    | USING typeName SEMI topLevelDecls
        { tbb (Using <| v \$2) \$1 \$3 :: \$4 }
    | NAMESPACE typeName LCURLY namespaceDecls RCURLY topLevelDecls
        { tbb (Namespace (v \$2, \$4)) \$1 \$3 :: \$6 }

namespaceDecls:
    | /* empty */
        { [] }
    | visibility classOrStruct TYPENAME possTypeParams ifaceImplements possConstraints LCURLY classDecls RCURLY namespaceDecls
        {   (nbb (Class (v \$3, \$1, \$2, ref \$5, \$8)) (p \$3) \$7, \$10)
            ||> applyTypeParamsConstraints \$4 \$6
        }
    | visibility INTERFACE TYPENAME possTypeParams ifaceImplements possConstraints LCURLY interfaceDecls RCURLY namespaceDecls
        {   (nbb (Interface (v \$3, \$1, ref \$5, \$8)) \$2 \$7, \$10)
            ||> applyTypeParamsConstraints \$4 \$6
        }

interfaceDecls:
    | /* empty */
        { [] }
    | IDENT possTypeParams LPAR params RPAR possReturnType possConstraints SEMI interfaceDecls
        {   (ibb (InterfaceProc (v \$1, \$4, ref \$6)) (p \$1) \$8, \$9)
            ||> applyTypeParamsConstraints \$2 \$7
        }

classDecls:
    | /* empty */
        { [] }
    | visibility static_ VAR IDENT COLON possType EQUALS expr3 SEMI classDecls
        { cbb (ClassVar (v \$4, \$1, \$2, ref \$6, \$8)) \$3 \$9 :: \$10 }
    | visibility static_ VAR IDENT COLON possType SEMI classDecls
        { cbb (ClassVar (v \$4, \$1, \$2, ref \$6, nop)) \$3 \$7 :: \$8 }
    | visibility static_ identOrBinop possTypeParams LPAR params RPAR possReturnType possConstraints LCURLY expr0OrNop RCURLY classDecls
        {   let cA = cbb (ClassProc (v (fst \$3), \$1, \$2, ref \$6, ref \$8, \$11)) (p <| fst \$3) \$10
            cA.IsBinop <- snd \$3
            applyTypeParamsConstraints \$4 \$9 cA \$13
        }

expr0OrNop:
    | /* empty */
        { nop }
    | expr0
        { \$1 }

expr0:
    | expr1
        { \$1 }
    | expr1 expr0
        { eaa (Seq (ref \$1, ref \$2)) \$1 \$2 }

expr1:
    /*| expr4 LSQUARE expr3 RSQUARE EQUALS expr3 SEMI
        {   let dot = eab (Dot (\$1, "indexer")) \$1 \$2
            eab (Call (dot, [\$3; \$6])) \$1 \$7 }*/
    | expr4 EQUALS expr3 SEMI
        {   eab (Assign (\$1, \$3)) \$1 \$4 }
    | VAR IDENT EQUALS expr3 SEMI
        {   let var = ea (Var (v \$2)) (p \$2)
            let assign = eba (Assign (var, \$4)) (p \$2) \$4
            eba (DeclVar (v \$2, assign)) \$1 \$4 }
    | RETURN expr3 SEMI
        { eba (Return <| \$2) \$1 \$2 }
    | RETURN SEMI
        { ea ReturnVoid \$1  }
    | IF LPAR expr3 RPAR expr1 ELSE expr1
        { eba (If (\$3, \$5, \$7)) \$1 \$5 }
    | IF LPAR expr3 RPAR expr1
        { eba (If (\$3, \$5, nop)) \$1 \$5 }
    | WHILE LPAR expr3 RPAR expr2
        { ebb (While (\$3, \$5)) \$1 \$4 }
    | expr2 
        { \$1 }

expr2:
    | expr3 SEMI
        { \$1 }
    | LCURLY expr0OrNop RCURLY
        { \$2 }

expr3:  
$for(binop in binops)\
    | expr3 $(binop) expr3
        { eaa (Binop (v \$2, \$1, \$3)) \$1 \$3 }
$endfor\
    | LSQUARE ptype RSQUARE expr4
        { eba (Cast (ref \$2, \$4)) \$1 \$4 } 
    | expr4
        { \$1 }

expr4:
    | IDENT
        { ea (Var (v \$1)) (p \$1) }
    | ptype
        { ea (VarStatic (ref \$1)) Pos.NilPos }
    | TRUE
        { ea (ConstBool true) \$1 }
    | FALSE
        { ea (ConstBool false) \$1 }
$for(x in [8,16,32,64])\
    | INT$(x)
        { ea (ConstInt ($(x), v \$1)) (p \$1) }
$endfor\
    | expr4 LPAR argList RPAR
        { eab (Call (\$1, \$3)) \$1 \$4 }
    /*| expr4 LSQUARE expr3 RSQUARE
        {   let dot = eab (Dot (\$1, "indexer")) \$1 \$2
            eab (Call (dot, [\$3])) \$1 \$4 
        }*/
    | expr5
        { \$1 }

expr5:
    | expr4 DOT IDENT
        { eab (Dot (\$1, v \$3)) \$1 (p \$3) }
    | expr4 DOT IDENT GENSPACEOP LSQUARE ptypeList RSQUARE
        { eab (DotTemplate (\$1, v \$3, ref \$6)) \$1 \$7 }
    | LPAR expr3 RPAR
        { \$2 }