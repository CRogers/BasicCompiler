%{

open Tree

let sp (itemA:Annot) = itemA.Pos.StartPos
let ep (itemA:Annot) = itemA.Pos.EndPos

let v = snd<Pos,_>
let p = fst<Pos,_>
let markers (lpos:Pos) (rpos:Pos) = Pos(lpos.StartPos, rpos.EndPos)

(*annotate using markers*)
let tbb item lpos rpos = TopDeclA(item, markers lpos rpos)
let tba item lpos (rightA:Annot)          = tbb item lpos rightA.Pos
let tab item (leftA:Annot) rpos           = tbb item leftA.Pos rpos
let taa item (leftA:Annot) (rightA:Annot) = tbb item leftA.Pos rightA.Pos

let nbb item lpos rpos = NamespaceDeclA(item, markers lpos rpos)
let nba item lpos (rightA:Annot)          = nbb item lpos rightA.Pos
let nab item (leftA:Annot) rpos           = nbb item leftA.Pos rpos
let naa item (leftA:Annot) (rightA:Annot) = nbb item leftA.Pos rightA.Pos

let cbb item lpos rpos = ClassDeclA(item, markers lpos rpos)
let cba item lpos (rightA:Annot)          = cbb item lpos rightA.Pos
let cab item (leftA:Annot) rpos           = cbb item leftA.Pos rpos
let caa item (leftA:Annot) (rightA:Annot) = cbb item leftA.Pos rightA.Pos

let ibb item lpos rpos = InterfaceDeclA(item, markers lpos rpos)
let iba item lpos (rightA:Annot)          = ibb item lpos rightA.Pos
let iab item (leftA:Annot) rpos           = ibb item leftA.Pos rpos
let iaa item (leftA:Annot) (rightA:Annot) = ibb item leftA.Pos rightA.Pos

let ebb item lpos rpos = ExprA(item, markers lpos rpos)
let eba item lpos (rightA:Annot)          = ebb item lpos rightA.Pos
let eab item (leftA:Annot) rpos           = ebb item leftA.Pos rpos
let eaa item (leftA:Annot) (rightA:Annot) = ebb item leftA.Pos rightA.Pos

let ea item pos = ExprA(item, pos)


let nop = ea Nop Pos.NilPos

%}

$py(binops=['BINOP' + str(x) for x in range(0,7)])

%token<(Pos * int64)>  INT8 INT16 INT32 INT64 
%token<(Pos * string)> IDENT$for(binop in binops) $(binop)$endfor
%token<Pos>            TRUE FALSE
%token<Pos>            LPAR RPAR EOF PRINT COMMA COLON
%token<Pos>            RETURN LCURLY RCURLY LSQUARE RSQUARE SEMI START PROC EQUALS LET
%token<Pos>            IF THEN ELSE WHILE DO VAR
%token<Pos>            NAMESPACE CLASS STRUCT INTERFACE
%token<Pos>            PRIVATE PUBLIC
%token<Pos>            STATIC CONSTRUCTOR
%token<Pos>            ARROW USING DOT SRO

%type<CompilationUnit> program
%start program

%left SEMI
$for(binop in binops)\
%left $(binop)
$endfor\
%right ARROW

%%

program: topLevelDecls EOF
    { \$1 }

topLevelDecls:
    | /* empty */
        { [] }
    | USING scopeResolvedName SEMI topLevelDecls
        { tbb (Using <| v \$2) \$1 \$3 :: \$4 }
    | NAMESPACE scopeResolvedName LCURLY namespaceDecls RCURLY topLevelDecls
        { tbb (Namespace (v \$2, \$4)) \$1 \$3 :: \$6 }

namespaceDecls:
    | /* empty */
        { [] }
    | visibility classOrStruct IDENT ifaceImplements LCURLY classDecls RCURLY namespaceDecls
        { nbb (Class (v \$3, \$1, \$2, ref \$4, \$6)) (p \$3) \$5 :: \$8 }
    | visibility INTERFACE IDENT ifaceImplements LCURLY interfaceDecls RCURLY namespaceDecls
        { nbb (Interface (v \$3, \$1, ref \$4, \$6)) \$2 \$5 :: \$8 }

interfaceDecls:
    | /* empty */
        { [] }
    | IDENT LPAR params RPAR possibleReturnType SEMI interfaceDecls
        { ibb (InterfaceProc (v \$1, \$3, ref \$5)) (p \$1) \$6 :: \$7 }

classDecls:
    | /* empty */
        { [] }
    | visibility static_ VAR IDENT COLON possibleType EQUALS expr3 SEMI classDecls
        { cbb (ClassVar (v \$4, \$1, \$2, ref \$6, \$8)) \$3 \$9 :: \$10 }
    | visibility static_ identOrBinop LPAR params RPAR possibleReturnType LCURLY expr0OrNop RCURLY classDecls
        { cba (ClassProc (v \$3, \$1, \$2, ref \$5, ref \$7, \$9)) (p \$3) \$9 :: \$11 }


expr0:
    | expr1
        { \$1 }
    | expr1 expr0
        { eaa (Seq (ref \$1, ref \$2)) \$1 \$2 }

expr1:
    | IDENT EQUALS expr3 SEMI
        {   let var = ea (Var <| v \$1) (p \$1) 
            ebb (Assign (var, \$3)) (p \$1) \$4 }
    | expr4 LSQUARE expr3 RSQUARE EQUALS expr3 SEMI
        {   let dot = eab (Dot (\$1, "indexer")) \$1 \$2
            eab (Call (dot, [\$3; \$6])) \$1 \$7 }
    | VAR IDENT EQUALS expr3 SEMI
        {   let var = ea (Var (v \$2)) (p \$2)
            let assign = eba (Assign (var, \$4)) (p \$2) \$4
            eba (DeclVar (v \$2, assign)) \$1 \$4 }
    | RETURN expr3 SEMI
        { eba (Return <| \$2) \$1 \$2 }
    | RETURN SEMI
        { ea ReturnVoid \$1  }
    | IF LPAR expr3 RPAR expr1 ELSE expr1
        { eba (If (\$3, \$5, \$7)) \$1 \$5 }
    | IF LPAR expr3 RPAR expr1
        { eba (If (\$3, \$5, nop)) \$1 \$5 }
    | WHILE LPAR expr3 RPAR expr2
        { ebb (While (\$3, \$5)) \$1 \$4 }
    | expr2 
        { \$1 }

expr2:
    | expr3 SEMI
        { \$1 }
    | LCURLY expr0OrNop RCURLY
        { \$2 }

expr3:  
$for(binop in binops)\
    | expr3 $(binop) expr3
        { eaa (Binop (v \$2, \$1, \$3)) \$1 \$3 }
$endfor\
    | LPAR scopeResolvedName RPAR expr4
        { eba (Cast (ref <| InitialType (v \$2), \$4)) \$1 \$4 } 
    | expr4
        { \$1 }

expr4:
    | LPAR RPAR
        { ebb ConstUnit \$1 \$2 }
    | scopeResolvedName
        { ea (Var (v \$1)) (p \$1) }
    | TRUE
        { ea (ConstBool true) \$1 }
    | FALSE
        { ea (ConstBool false) \$1 }
$for(x in [8,16,32,64])\
    | INT$(x)
        { ea (ConstInt ($(x), v \$1)) (p \$1) }
$endfor\
    | expr4 LPAR argList RPAR  
        { eab (Call (\$1, \$3)) \$1 \$4 }
    | expr4 LSQUARE expr3 RSQUARE
        {   let dot = eab (Dot (\$1, "indexer")) \$1 \$2
            eab (Call (dot, [\$3])) \$1 \$4 
        }
    | expr5
        { \$1 }

expr5:
    | expr4 DOT IDENT
        { eab (Dot (\$1, v \$3)) \$1 (p \$3) }
    | LPAR expr3 RPAR
        { \$2 }


visibility:
    | /* empty */
        { Private }
    | PRIVATE
        { Private }
    | PUBLIC
        { Public }

static_:
    | /* empty */
        { NotStatic }
    | STATIC
        { Static }

classOrStruct:
    | STRUCT
        { Struct }
    | CLASS
        { NotStruct }

scopeResolvedName:
    | IDENT
        { \$1 }
    | IDENT SRO scopeResolvedName
        { (markers (p \$1) (p \$3), v \$1 + "::" + v \$3) }

ifaceImplements:
    | /* empty */
        { [] }
    | COLON ifaceImplements2
        { \$2 }    

ifaceImplements2:
    | scopeResolvedName
        { [InitialType <| v \$1] }
    | scopeResolvedName COMMA ifaceImplements2
        { (InitialType <| v \$1) :: \$3 }

identOrBinop:
    | IDENT
        { \$1 }
$for(binop in binops)\
    | $(binop)
        { \$1 }
$endfor\

possibleType:
    | /* empty */
        { Undef }
    | ptype
        { \$1 }

ptype:
    | scopeResolvedName
        { InitialType (v \$1) }

ptypeList:
    | /* empty */
        { [] }
    | ptype COMMA ptypeList
        { \$1 :: \$3 }

possibleReturnType:
    | /* empty */
        { InitialType "System::Unit" }
    | COLON ptype
        { \$2 }

params:
    | /* empty */
        { [] }
    | IDENT COLON ptype
        { [Param(v \$1, \$3)] }
    | IDENT COLON ptype COMMA params
        { Param(v \$1, \$3) :: \$5 }

expr0OrNop:
    | /* empty */
        { nop }
    | expr0
        { \$1 }


argList:
    | /* empty */
        { [] }
    | expr3
        { [\$1] }
    | expr3 COMMA argList
        { \$1 :: \$3 }