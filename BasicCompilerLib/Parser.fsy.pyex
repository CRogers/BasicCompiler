%{

open Tree

let sp (itemA:Annot<_>) = itemA.Pos.StartPos
let ep (itemA:Annot<_>) = itemA.Pos.EndPos

let v = snd<Pos,_>
let p = fst<Pos,_>
let markers (lpos:Pos) (rpos:Pos) = Pos(lpos.StartPos, rpos.EndPos)

(*annotate*)
let a item pos = Annot(item, pos)
(*annotate using markers*)
let ambb item lpos rpos = Annot(item, markers lpos rpos)
let amba item lpos (rightA:Annot<_>) = ambb item lpos rightA.Pos
let amab item (leftA:Annot<_>) rpos = ambb item leftA.Pos rpos
(*annotate using markers that are annotated*)
let amaa item (leftA:Annot<_>) (rightA:Annot<_>) = ambb item leftA.Pos rightA.Pos

%}

$py(binops=['Add','Sub','Div','Mul','BoolAnd','BoolOr','Not','Lt','Gt','LtEq','GtEq','Eq'])

%token<(Pos * int64)>  INT8 INT16 INT32 INT64 
%token<(Pos * string)> IDENT
%token<Pos>            TRUE FALSE
%token<Pos>            $for(binop in binops)$(binop.upper()) $endfor
%token<Pos>            LPAR RPAR EOF PRINT COMMA COLON
%token<Pos>            RETURN LCURLY RCURLY SEMI START PROC EQUALS LET
%token<Pos>            IF THEN ELSE WHILE DO VAR
%token<Pos>            NAMESPACE CLASS INTERFACE
%token<Pos>            PRIVATE PUBLIC
%token<Pos>            STATIC CONSTRUCTOR
%token<Pos>            ARROW USING DOT SRO

%type<Program> program
%start program

%left SEMI
%left BOOLOR
%left BOOLAND
%left NOT
%left LT GT LTEQ GTEQ EQ
%left ADD SUB
%left DIV
%left MUL

%right ARROW

%%

program: topLevelDecls EOF
    { \$1 }

topLevelDecls:
    | /* empty */
        { [] }
    | USING scopeResolvedName SEMI topLevelDecls
        { ambb (Using \$2) \$1 \$3 :: \$4 }
    | NAMESPACE scopeResolvedName LCURLY namespaceDecls RCURLY topLevelDecls
        { ambb (Namespace (\$2, \$4)) \$1 \$3 :: \$6 }

scopeResolvedName:
    | IDENT
        { v \$1 }
    | IDENT SRO scopeResolvedName
        { v \$1 + "::" + \$3 }

visibility:
    | /* empty */
        { Private }
    | PRIVATE
        { Private }
    | PUBLIC
        { Public }

namespaceDecls:
    | /* empty */
        { [] }
    | visibility CLASS IDENT LCURLY classDecls RCURLY namespaceDecls
        { ambb (Class (v \$3, \$1, \$5)) \$2 \$4 :: \$7 }
    | visibility INTERFACE IDENT LCURLY interfaceDecls RCURLY namespaceDecls
        { ambb (Interface (v \$3, \$1, \$5)) \$2 \$4 :: \$7 }

interfaceDecls:
    | /* empty */
        { [] }
    | IDENT LPAR params RPAR possibleReturnType SEMI interfaceDecls
        { ambb (InterfaceProc (v \$1, \$3, \$5)) (p \$1) \$6 :: \$7 }

possibleType:
    | /* empty */
        { Undef }
    | ptype
        { \$1 }

ptype:
    | LPAR RPAR
        { Unit }
    | scopeResolvedName
        { UserType \$1 }
    | ptype ARROW ptype
        { PFunc (\$1, \$3) }
    | LPAR ptype RPAR
        { \$2 }

static:
    | /* empty */
        { NotStatic }
    | STATIC
        { Static }

ctor:
    | /* empty */
        { Ctor }
    | CONSTRUCTOR
        { NotCtor }

classDecls:
    | /* empty */
        { [] }
    | visibility static VAR IDENT COLON possibleType EQUALS expr3 SEMI classDecls
        { ambb (ClassVar (v \$4, \$1, \$2, \$6, \$8)) \$3 \$9 :: \$10 }
    | visibility static ctor IDENT LPAR params RPAR possibleReturnType EQUALS expr2 classDecls
        { 
            let isStatic = if  (\$3 = Static) || (\$2 = Ctor) then Static else NotStatic
            amba (ClassProc (v \$4, \$1, isStatic, \$3 \$6, \$8, \$10)) (p \$4) \$10 :: \$11
        }

possibleReturnType:
    | /* empty */
        { Unit }
    | ptype
        { \$1 }

params:
    | /* empty */
        { [] }
    | IDENT COLON ptype COMMA params
        { Param(v \$1, \$3) :: \$5 }


expr0:
    | expr1
        { \$1 }
    | expr1 expr0
        { amaa (Seq (\$1, \$2)) \$1 \$2 }

expr1:
    | IDENT EQUALS expr3 SEMI
        { amba (Assign (v \$1, \$3)) (p \$1) \$3 }
    | PRINT expr3 SEMI
        { amba (Print \$2) \$1 \$2 }
    | VAR IDENT EQUALS expr3 SEMI
        { amba (DeclVar (v \$2, amba (Assign (v \$2, \$4)) (p \$2) \$4)) \$1 \$4 }
    | RETURN expr3 SEMI
        { amba (Return \$2) \$1 \$2 }
    | IF LPAR expr3 RPAR expr2 ELSE expr2 SEMI
        { amba (If (\$3, \$5, \$7)) \$1 \$5 }
    | WHILE LPAR expr3 RPAR expr2
        { ambb (While (\$3, \$5)) \$1 \$4 }
    | expr2 
        { \$1 }

expr2:
    | expr3 SEMI
        { \$1 }
    | LCURLY expr0 RCURLY
        { \$2 }

expr3:
    | LPAR RPAR
        { ambb ConstUnit \$1 \$2 }
$for(x in [8,16,32,64])\
    | INT$(x)
        { a (ConstInt ($(x), v \$1)) (p \$1) }
$endfor\
    | TRUE
        { a (ConstBool true) \$1 }
    | FALSE
        { a (ConstBool false) \$1 }    
$for(binop in binops)\
    | expr3 $(binop.upper()) expr3
        { amaa (Binop ($(binop), \$1, \$3)) \$1 \$3 }
$endfor\
    | expr4 LPAR argList RPAR  
        { ambb (Call (v \$1, \$3)) (p \$1) \$4 }
    | IDENT
        { a (Var (v \$1)) (p \$1) }
    | expr4
        { \$1 }

expr4:
    | expr4 DOT IDENT
        { amab (Dot (\$1, \$3)) \$1 \$3 }
    | LPAR expr3 RPAR
        { \$2 }

argList:
    | /* empty */
        { [] }
    | expr3 COMMA argList
        { \$1 :: \$3 }