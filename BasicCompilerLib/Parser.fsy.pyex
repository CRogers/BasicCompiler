%{

open Tree

let sp (itemA:Annot<_>) = itemA.Pos.StartPos
let ep (itemA:Annot<_>) = itemA.Pos.EndPos

let v = snd<Pos,_>
let p = fst<Pos,_>
let markers (lpos:Pos) (rpos:Pos) = Pos(lpos.StartPos, rpos.EndPos)

(*annotate*)
let a item pos = Annot(item, pos)
(*annotate using markers*)
let ambb item lpos rpos = Annot(item, markers lpos rpos)
let amba item lpos (rightA:Annot<_>) = ambb item lpos rightA.Pos
let amab item (leftA:Annot<_>) rpos = ambb item leftA.Pos rpos
(*annotate using markers that are annotated*)
let amaa item (leftA:Annot<_>) (rightA:Annot<_>) = ambb item leftA.Pos rightA.Pos

%}

$py(binops=['Add','Sub','Div','Mul','BoolAnd','BoolOr','Not','Lt','Gt','LtEq','GtEq','Eq'])

%token<(Pos * int)>    CONSTINT
%token<(Pos * string)> IDENT
%token<Pos>            TRUE FALSE
%token<Pos>            $for(binop in binops)$(binop.upper()) $endfor
%token<Pos>            LPAR RPAR EOF PRINT COMMA COLON
%token<Pos>            RETURN LCURLY RCURLY SEMI START PROC EQUALS LET
%token<Pos>            IF THEN ELSE WHILE DO VAR

%type<Program> program
%start program

%left SEMI
%left BOOLOR
%left BOOLAND
%left NOT
%left LT GT LTEQ GTEQ EQ
%left ADD SUB
%left DIV
%left MUL

%%

program: decls EOF                  { \$1 }

decls:
    | procDecls START block         { ambb (Proc ("main", [], Int 32, v \$3)) \$2 (p \$3) :: \$1 }


procDecls:
    | /* empty */                   { [] }
    | PROC IDENT LPAR paramList RPAR returnType block procDecls
        { ambb (Proc (v \$2, \$4, \$6, v \$7)) \$1 (p \$7) :: \$8 }

returnType:
    | /* empty */                   { Unit }
    | COLON IDENT                   { parsePType <| v \$2 }

paramList:
    | /* empty */                   { [] }
    | param                         { [\$1] }
    | param COMMA paramList         { \$1 :: \$3 }

param:
    | IDENT COLON IDENT             { Param (v \$1, parsePType <| v \$3) }

block:
    | LCURLY expr0 RCURLY            { (Pos(\$1.StartPos, \$3.EndPos), \$2) }

expr0:
    | expr1 SEMI expr0               { amaa (Seq (\$1, \$3)) \$1 \$3}
    | expr1 SEMI                     { \$1 }
    | expr1                          { \$1 }

expr1:
    | IDENT EQUALS expr1
        { amba (Assign (v \$1, \$3)) (p \$1) \$3 }
    | PRINT expr1
        { amba (Print \$2) \$1 \$2 }
    | VAR IDENT EQUALS expr1
        { amba (DeclVar (v \$2, amba (Assign (v \$2, \$4)) (p \$2) \$4)) \$1 \$4 }
    | RETURN expr1
        { amba (Return \$2) \$1 \$2 }
    | IF expr1 THEN expr1 ELSE expr1
        { ambb (If (\$2, \$4, \$4)) \$1 \$5 }
    | WHILE expr1 DO expr1
        { amba (While (\$2, \$4)) \$1 \$4 }
    | expr
        { \$1 }

expr:
    | CONSTINT
        { a (ConstInt (v \$1)) (p \$1) }
    | TRUE
        { a (ConstBool true) \$1 }
    | FALSE
        { a (ConstBool false) \$1 }    
$for(binop in binops)\
    | expr $(binop.upper()) expr
        { amaa (Binop ($(binop), \$1, \$3)) \$1 \$3 }
$endfor\
    | IDENT LPAR argList RPAR       
        { ambb (Call (v \$1, \$3)) (p \$1) \$4 }
    | IDENT
        { a (Var (v \$1)) (p \$1) }
    | LPAR expr1 RPAR
        { \$2 }
    | LCURLY expr0 RCURLY
        { \$2 }
    

argList:
    | /* empty */                   { [] }
    | expr                          { [\$1] }
    | expr COMMA argList            { \$1 :: \$3 }