%{

open Tree

let sp (itemA:Annot<_>) = itemA.Pos.StartPos
let ep (itemA:Annot<_>) = itemA.Pos.EndPos

let v = snd<Pos,_>
let p = fst<Pos,_>
let markers (lpos:Pos) (rpos:Pos) = Pos(lpos.StartPos, rpos.EndPos)

(*annotate*)
let a item pos = Annot(item, pos)
(*annotate using markers*)
let ambb item lpos rpos = Annot(item, markers lpos rpos)
let amba item lpos (rightA:Annot<_>) = ambb item lpos rightA.Pos
let amab item (leftA:Annot<_>) rpos = ambb item leftA.Pos rpos
(*annotate using markers that are annotated*)
let amaa item (leftA:Annot<_>) (rightA:Annot<_>) = ambb item leftA.Pos rightA.Pos

%}

$py(binops=['Add','Sub','Div','Mul','BoolAnd','BoolOr','Not','Lt','Gt','LtEq','GtEq','Eq'])

%token<(Pos * int64)>  INT8 INT16 INT32 INT64 
%token<(Pos * string)> IDENT
%token<Pos>            TRUE FALSE
%token<Pos>            $for(binop in binops)$(binop.upper()) $endfor
%token<Pos>            LPAR RPAR EOF PRINT COMMA COLON
%token<Pos>            RETURN LCURLY RCURLY SEMI START PROC EQUALS LET
%token<Pos>            IF THEN ELSE WHILE DO VAR
%token<Pos>            NAMESPACE CLASS INTERFACE
%token<Pos>            PRIVATE PUBLIC
%token<Pos>            ARROW USING DOT

%type<Program> program
%start program

%left SEMI
%left BOOLOR
%left BOOLAND
%left NOT
%left LT GT LTEQ GTEQ EQ
%left ADD SUB
%left DIV
%left MUL

%right ARROW

%%

program: topLevelDecls EOF
    { \$1 }

topLevelDecls:
    | /* empty */
        { [] }
    | USING identDotSeq SEMI topLevelDecls
        { ambb (Using \$2) \$1 \$3 :: \$4 }
    | NAMESPACE identDotSeq LCURLY namespaceDecls RCURLY topLevelDecls
        { ambb (Namespace (\$2, \$4)) \$1 \$3 :: \$6 }

identDotSeq:
    | IDENT
        { v \$1 }
    | IDENT DOT identDotSeq
        { \$1 + "." + \$3 }

visibility:
    | /* empty */
        { Private }
    | PRIVATE
        { Private }
    | PUBLIC
        { Public }

namespaceDecls:
    | /* empty */
        { [] }
    | visibility CLASS IDENT LCURLY classDecls RCURLY namespaceDecls
        { ambb (Class (v \$3, \$2, \$5)) \$1 \$4 :: \$7 }
    | visibility INTERFACE IDENT LCURLY interfaceDecls RCURLY namespaceDecls
        { ambb (Interface (v \$3, \$1, \$5)) \$2 \$4 :: \$7 }

interfaceDecls:
    | /* empty */
        { [] }
    | IDENT LPAR params RPAR SEMI interfaceDecls
        { amab (InterfaceProc (v \$1, \$3)) (p \$1) \$4 :: \$5 }

possibleType:
    | /* empty */
        { Undef }
    | type
        { \$1 }

type:
    | LPAR RPAR
        { Unit }
    | identDotSeq
        { match \$1 with
            | "Int8"  -> Int 8
            | "Int16" -> Int 16
            | "Int32" -> Int 32
            | "Int64" -> Int 64
            | "Bool"  -> Bool
            | _ -> UserType \$1
        }
    | type ARROW type
        { PFunc (\$1, \$3) }
    | LPAR type RPAR
        { \$2 }

classDecls:
    | /* empty */
        { [] }
    | visibility VAR IDENT COLON possibleType EQUALS expr3 SEMI classDecls
        { ambb (ClassVar (\$3, \$1, \$5, \$7)) \$2 \$8 :: \$9 }
    | visibility IDENT LPAR params RPAR possibleReturnType EQUALS expr2
        { amba (ClassProc (\$2, \$1, \$4, \$6, \$8)) \$2 \$8 }

possibleReturnType:
    | /* empty */
        { Unit }
    | type
        { \$1 }

params:
    | /* empty */
        { [] }
    | param params
        { \$1 :: \$2 }

param:
    | IDENT
        { Param(\$1, Undef) }
    | LPAR IDENT COLON type RPAR
        { Param(\$1, \$3) }


expr0:
    | expr1
        { \$1 }
    | expr1 expr0
        { amaa (Seq (\$1, \$2)) \$1 \$2 }

expr1:
    | IDENT EQUALS expr3 SEMI
        { amba (Assign (v \$1, \$3)) (p \$1) \$3 }
    | PRINT expr3 SEMI
        { amba (Print \$2) \$1 \$2 }
    | VAR IDENT EQUALS expr3 SEMI
        { amba (DeclVar (v \$2, amba (Assign (v \$2, \$4)) (p \$2) \$4)) \$1 \$4 }
    | RETURN expr3 SEMI
        { amba (Return \$2) \$1 \$2 }
    | IF LPAR expr3 RPAR expr2 ELSE expr2 SEMI
        { ambb (If (\$3, \$5, \$7)) \$1 \$5 }
    | WHILE LPAR expr3 RPAR expr2
        { amba (While (\$3, \$5)) \$1 \$4 }
    | expr2 
        { \$1 }

expr2:
    | expr3 SEMI
        { \$1 }
    | LCURLY expr0 RCURLY
        { \$2 }

expr3:
    | LPAR RPAR
        { ambb ConstUnit \$1 \$2 }
$for(x in [8,16,32,64])\
    | INT$(x)
        { a (ConstInt ($(x), v \$1)) (p \$1) }
$endfor\
    | TRUE
        { a (ConstBool true) \$1 }
    | FALSE
        { a (ConstBool false) \$1 }    
$for(binop in binops)\
    | expr3 $(binop.upper()) expr3
        { amaa (Binop ($(binop), \$1, \$3)) \$1 \$3 }
$endfor\
    | IDENT callExprList  
        { ambb (Call (v \$1, \$3)) (p \$1) \$4 }
    | IDENT
$py(varRule="(a (Var (v \$1)) (p \$1))")
        { $(varRule) }
    | LPAR expr3 RPAR
        { \$2 }


callExprList:
    | bareIdentOrExpr
        { \$1 }
    | bareIdentOrExpr callExprList
        { \$1 :: \$2 }

bareIdentOrExpr:
    | IDENT
        { [$(varRule)] }
    | LPAR expr3 RPAR
        { \$2 }