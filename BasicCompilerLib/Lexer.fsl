{

module Lexer

open System
open Microsoft.FSharp.Text.Lexing
open Parser
open Tree

let lineno = ref 1

let lexeme = Lexing.LexBuffer<_>.LexemeString
let newline (lexbuf:LexBuffer<_>) = lexbuf.EndPos <- lexbuf.EndPos.NextLine
let pos (lexbuf:LexBuffer<_>) = Pos(lexbuf.StartPos, lexbuf.EndPos)

let keywords = Map<string,(Pos -> token)>(
    [("print", PRINT); ("proc", PROC); ("return", RETURN);
    ("start", START)])

let kwOrIdent lexbuf =
    let item = lexeme lexbuf
    let pos = pos lexbuf
    if keywords.ContainsKey(item) then
        keywords.[item] pos
    else 
        IDENT (pos, item)

let symbols = Map<string,(Pos -> token)>(
    [("(", LPAR); (")", RPAR); ("{", LCURLY); ("}", RCURLY);
    ("+", ADD); ("-", SUB); ("/", DIV); ("*", MUL); (":", COLON); (";", SEMI);
    (",", COMMA); ("=", EQUALS)])

let symbolOrFail lexbuf =
    let item = lexeme lexbuf
    if symbols.ContainsKey(item) then
        symbols.[item] (pos lexbuf)
    else
        failwithf "Lexing fail for %s" item

}

let integer = ['0'-'9']+
let ident = ['a'-'z' 'A'-'Z' '_']+
let white = [' ' '\t']
let endline = '\r'? '\n'

rule token = parse
    | white+                { token lexbuf }
    | endline               { newline lexbuf; token lexbuf }
    | eof                   { EOF (pos lexbuf) }
    | integer               { CONSTINT (pos lexbuf, Int32.Parse(lexeme lexbuf)) }
    | ident                 { kwOrIdent lexbuf }
    | _                     { symbolOrFail lexbuf }