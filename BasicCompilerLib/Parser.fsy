%{

open Tree

%}

%token<int>    CONSTINT
%token<string> IDENT
%token         ADD SUB DIV MUL LPAR RPAR EOF PRINT COMMA COLON
%token         RETURN LCURLY RCURLY SEMI START PROC EQUALS LET

%type<Program> program
%start program

%left ADD SUB
%left DIV
%left MUL

%%

program: decls EOF                  { $1 }

decls:
    | procDecls START block         { Annot (Proc ("main", [], Unit, $3)) :: $1 }


procDecls:
    | /* empty */                   { [] }
    | PROC IDENT LPAR paramList RPAR returnType block procDecls
        { Annot (Proc ($2, $4, $6, $7)) :: $8 }

returnType:
    | /* empty */                   { Unit }
    | COLON IDENT                   { parsePType $2 }

paramList:
    | /* empty */                   { [] }
    | param                         { [$1] }
    | param COMMA paramList         { $1 :: $3 }

param:
    | IDENT COLON IDENT             { Param ($1, parsePType $3) }

block:
    | LCURLY stmts RCURLY           { $2 }

stmts:
    | /* empty */                   { [] }
    | stmt SEMI stmts               { $1 :: $3 }

stmt:
    | PRINT expr                    { Annot (Print $2) }
    | IDENT EQUALS expr             { Annot (Assign ($1, $3)) }
    | RETURN expr                   { Annot (Return $2) }

expr:
    | CONSTINT                      { Annot (ConstInt $1) }
    | expr ADD expr                 { Annot (Binop (Add, $1, $3)) }
    | expr SUB expr                 { Annot (Binop (Sub, $1, $3)) }
    | expr DIV expr                 { Annot (Binop (Div, $1, $3)) }
    | expr MUL expr                 { Annot (Binop (Mul, $1, $3)) }
    | IDENT LPAR argList RPAR       { Annot (Call ($1, $3)) }
	| IDENT							{ Annot (Var $1) }
    | LPAR expr RPAR                { $2 }

argList:
    | /* empty */                   { [] }
    | expr                          { [$1] }
    | expr COMMA argList            { $1 :: $3 }