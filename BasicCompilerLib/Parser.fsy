%{

open Tree

let sp (itemA:Annot<_>) = itemA.Pos.StartPos
let ep (itemA:Annot<_>) = itemA.Pos.EndPos

let v = snd<Pos,_>
let p = fst<Pos,_>
let markers (lpos:Pos) (rpos:Pos) = Pos(lpos.StartPos, rpos.EndPos)

(*annotate*)
let a item pos = Annot(item, pos)
(*annotate using markers*)
let ambb item lpos rpos = Annot(item, markers lpos rpos)
let amba item lpos (rightA:Annot<_>) = ambb item lpos rightA.Pos
let amab item (leftA:Annot<_>) rpos = ambb item leftA.Pos rpos
(*annotate using markers that are annotated*)
let amaa item (leftA:Annot<_>) (rightA:Annot<_>) = ambb item leftA.Pos rightA.Pos

%}

%token<(Pos * int)>    CONSTINT
%token<(Pos * string)> IDENT
%token<Pos>            ADD SUB DIV MUL LPAR RPAR EOF PRINT COMMA COLON
%token<Pos>            RETURN LCURLY RCURLY SEMI START PROC EQUALS LET

%type<Program> program
%start program

%left ADD SUB
%left DIV
%left MUL

%%

program: decls EOF                  { $1 }

decls:
    | procDecls START block         { ambb (Proc ("main", [], Unit, v $3)) $2 (p $3) :: $1 }


procDecls:
    | /* empty */                   { [] }
    | PROC IDENT LPAR paramList RPAR returnType block procDecls
        { ambb (Proc (v $2, $4, $6, v $7)) $1 (p $7) :: $8 }

returnType:
    | /* empty */                   { Unit }
    | COLON IDENT                   { parsePType <| v $2 }

paramList:
    | /* empty */                   { [] }
    | param                         { [$1] }
    | param COMMA paramList         { $1 :: $3 }

param:
    | IDENT COLON IDENT             { Param (v $1, parsePType <| v $3) }

block:
    | LCURLY stmts RCURLY           { (Pos($1.StartPos, $3.EndPos), $2) }

stmts:
    | /* empty */                   { [] }
    | stmt SEMI stmts               { $1 :: $3 }

stmt:
    | PRINT expr                    { amba (Print $2) $1 $2 }
    | IDENT EQUALS expr             { amba (Assign (v $1, $3)) (p $1) $3 }
    | RETURN expr                   { amba (Return $2) $1 $2 }

expr:
    | CONSTINT
        { a (ConstInt (v $1)) (p $1) }
    | expr ADD expr
        { amaa (Binop (Add, $1, $3)) $1 $3 }
    | expr SUB expr
        { amaa (Binop (Sub, $1, $3)) $1 $3 }
    | expr DIV expr
        { amaa (Binop (Div, $1, $3)) $1 $3 }
    | expr MUL expr
        { amaa (Binop (Mul, $1, $3)) $1 $3 }
    | IDENT LPAR argList RPAR       
        { ambb (Call (v $1, $3)) (p $1) $4 }
	| IDENT
        { a (Var (v $1)) (p $1) }
    | LPAR expr RPAR
        { $2 }

argList:
    | /* empty */                   { [] }
    | expr                          { [$1] }
    | expr COMMA argList            { $1 :: $3 }