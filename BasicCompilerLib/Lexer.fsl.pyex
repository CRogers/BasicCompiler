{

module Lexer

open System
open Microsoft.FSharp.Text.Lexing
open Parser
open Tree

let lineno = ref 1

let lexeme = Lexing.LexBuffer<_>.LexemeString
let newline (lexbuf:LexBuffer<_>) = lexbuf.EndPos <- lexbuf.EndPos.NextLine
let pos (lexbuf:LexBuffer<_>) = Pos(lexbuf.StartPos, lexbuf.EndPos)

$py(defs=[("print", "PRINT"), ("proc", "PROC"), ("return", "RETURN")])\
$py(defs+=[("true", "TRUE"), ("false", "FALSE"), ("start", "START")])\
$py(defs+=[("if", "IF"), ("then", "THEN"), ("else", "ELSE"), ("while", "WHILE"), ("do", "DO"), ("var", "VAR")])\
$py(defs+=[("namespace", "NAMESPACE"),("class", "CLASS"), ("interface", "INTERFACE")])\
$py(defs+=[("using", "USING"), ("static", "STATIC"), ("constructor", "CONSTRUCTOR")])\

$py(defs+=[("(", "LPAR"), (")", "RPAR"), ("{", "LCURLY"), ("}", "RCURLY")])\
$py(defs+=[("+", "ADD"), ("-", "SUB"), ("/", "DIV"), ("*", "MUL"), (":", "COLON"), (";", "SEMI")])\
$py(defs+=[(",", "COMMA"), ("=", "EQUALS"), ("&&", "BOOLAND"), ("||", "BOOLOR"), ("!", "NOT")])\
$py(defs+=[("<", "LT"), (">", "GT"), ("<=", "LTEQ"), (">=", "GTEQ"), ("==", "EQ")])\
$py(defs+=[(".", "DOT"), ("->", "ARROW"), ("::", "SRO")])\

}

let integer = ['0'-'9']+
let ident = ['a'-'z' 'A'-'Z' '_']+
let white = [' ' '\t']
let endline = '\r'? '\n'

rule token = parse
    | white+                { token lexbuf }
    | endline               { newline lexbuf; token lexbuf }
    | eof                   { EOF (pos lexbuf) }
    | integer               { INT32 (pos lexbuf, Int64.Parse(lexeme lexbuf)) }
    | integer 'B'           { INT8  (pos lexbuf, Int64.Parse(lexeme lexbuf)) }
    | integer 'S'           { INT16 (pos lexbuf, Int64.Parse(lexeme lexbuf)) }
    | integer 'L'           { INT64 (pos lexbuf, Int64.Parse(lexeme lexbuf)) }
$for((str, defn) in defs)\
    | "$(str)"              { $(defn) (pos lexbuf) }
$endfor\
    | ident                 { IDENT (pos lexbuf, lexeme lexbuf) }
    | _                     { failwithf "Lexing fail for %s" (lexeme lexbuf) }